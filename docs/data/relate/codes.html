<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Relation Vectors &mdash; seismic-rna  documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
    <link rel="shortcut icon" href="../../_static/favicon-32x32.ico"/>
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../_static/documentation_options.js?v=5929fcd5"></script>
        <script src="../../_static/doctools.js?v=9a2dae69"></script>
        <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Relate Batch" href="relate.html" />
    <link rel="prev" title="Relate Data Structures" href="index.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            seismic-rna
              <img src="../../_static/logo-200.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../about/index.html">About</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../install/index.html">Install</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../steps/index.html">Step-By-Step</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../howto/index.html">How To</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cli.html">Commands, Arguments, Options</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api/seismicrna.html">seismicrna package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../formats/index.html">File Formats</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">Data Structures</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="index.html">Relate Data Structures</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="#">Relation Vectors</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#relationships-between-reads-and-references">Relationships between reads and references</a></li>
<li class="toctree-l4"><a class="reference internal" href="#encoding-primary-relationships">Encoding primary relationships</a></li>
<li class="toctree-l4"><a class="reference internal" href="#encoding-ambiguous-relationships">Encoding ambiguous relationships</a></li>
<li class="toctree-l4"><a class="reference internal" href="#encoding-positions-not-covered-by-the-read">Encoding positions not covered by the read</a></li>
<li class="toctree-l4"><a class="reference internal" href="#encoding-paired-end-reads">Encoding paired-end reads</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="relate.html">Relate Batch</a></li>
<li class="toctree-l3"><a class="reference internal" href="qnames.html">Read Names Batch</a></li>
<li class="toctree-l3"><a class="reference internal" href="refseq.html">Reference Sequence</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../algos/index.html">Algorithms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../issues.html">Bugs and Requests</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../writeme.html">How to Write this Manual</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">seismic-rna</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Data Structures</a></li>
          <li class="breadcrumb-item"><a href="index.html">Relate Data Structures</a></li>
      <li class="breadcrumb-item active">Relation Vectors</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/data/relate/codes.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="relation-vectors">
<h1>Relation Vectors<a class="headerlink" href="#relation-vectors" title="Link to this heading"></a></h1>
<section id="relationships-between-reads-and-references">
<h2>Relationships between reads and references<a class="headerlink" href="#relationships-between-reads-and-references" title="Link to this heading"></a></h2>
<p>A relation vector encodes the relationship between one sequencing read (or pair
of mated reads) and each base in the reference sequence.
SEISMIC-RNA defines eight primary relationships:</p>
<ul class="simple">
<li><p><strong>Match</strong>: The reference base aligned to a high-quality base of the same kind
in the read.</p></li>
<li><p><strong>Deletion</strong>: The reference base aligned between two bases in the read.</p></li>
<li><p><strong>5’ of Insertion</strong>: The reference base aligned to any read base immediately
5’ of an extra base in the read.</p></li>
<li><p><strong>3’ of Insertion</strong>: The reference base aligned to any read base immediately
3’ of an extra base in the read.</p></li>
<li><p><strong>Substitution to A</strong>: The reference base is not A, and it aligned to a
high-quality A in the read.</p></li>
<li><p><strong>Substitution to C</strong>: The reference base is not C, and it aligned to a
high-quality C in the read.</p></li>
<li><p><strong>Substitution to G</strong>: The reference base is not G, and it aligned to a
high-quality G in the read.</p></li>
<li><p><strong>Substitution to T</strong>: The reference base is not T, and it aligned to a
high-quality T in the read.</p></li>
</ul>
<p>This figure illustrates six of these primary relationships, as well the “blank”
relationship for positions in the reference outside the span of the read.</p>
<img alt="../../_images/relationships.png" src="../../_images/relationships.png" />
</section>
<section id="encoding-primary-relationships">
<h2>Encoding primary relationships<a class="headerlink" href="#encoding-primary-relationships" title="Link to this heading"></a></h2>
<p>Each position in a relation vector is physically represented by one byte (eight
bits); each bit corresponds to one of the eight types of primary relationship.
For a given position in the relation vector, the byte(s) corresponding to the
relationship(s) at that position are turned on (set to 1); all other bits are
set to 0.
The following table indicates which relationship each bit represents.
Each bit is shown as the sole 1 within an entire byte (8-digit binary number).
The number’s decimal (Dec) and hexadecimal (Hex) forms are also shown.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Byte</p></th>
<th class="head"><p>Dec</p></th>
<th class="head"><p>Hex</p></th>
<th class="head"><p>Relationship</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>00000001</p></td>
<td><p>001</p></td>
<td><p>01</p></td>
<td><p>Match</p></td>
</tr>
<tr class="row-odd"><td><p>00000010</p></td>
<td><p>002</p></td>
<td><p>02</p></td>
<td><p>Deletion</p></td>
</tr>
<tr class="row-even"><td><p>00000100</p></td>
<td><p>004</p></td>
<td><p>04</p></td>
<td><p>5’ of Insertion</p></td>
</tr>
<tr class="row-odd"><td><p>00001000</p></td>
<td><p>008</p></td>
<td><p>08</p></td>
<td><p>3’ of Insertion</p></td>
</tr>
<tr class="row-even"><td><p>00010000</p></td>
<td><p>016</p></td>
<td><p>10</p></td>
<td><p>Substitution to A</p></td>
</tr>
<tr class="row-odd"><td><p>00100000</p></td>
<td><p>032</p></td>
<td><p>20</p></td>
<td><p>Substitution to C</p></td>
</tr>
<tr class="row-even"><td><p>01000000</p></td>
<td><p>064</p></td>
<td><p>40</p></td>
<td><p>Substitution to G</p></td>
</tr>
<tr class="row-odd"><td><p>10000000</p></td>
<td><p>128</p></td>
<td><p>80</p></td>
<td><p>Substitution to T</p></td>
</tr>
</tbody>
</table>
</section>
<section id="encoding-ambiguous-relationships">
<h2>Encoding ambiguous relationships<a class="headerlink" href="#encoding-ambiguous-relationships" title="Link to this heading"></a></h2>
<p>Oh, if only encoding relation vectors were that straightforward!
Though most bases in a read will have primary relationships with the bases in
the reference to which they align, two phenomena make it more difficult for some
bases to define the relationship:</p>
<ul class="simple">
<li><p>low-quality base calls</p></li>
<li><p>ambiguous insertions and deletions</p></li>
</ul>
<section id="encoding-low-quality-base-calls">
<span id="relate-low-qual"></span><h3>Encoding low-quality base calls<a class="headerlink" href="#encoding-low-quality-base-calls" title="Link to this heading"></a></h3>
<p>A low-quality base call is defined as having a <a class="reference external" href="https://en.wikipedia.org/wiki/Phred_quality_score">Phred quality score</a> below the
user-specified threshold (default: 25).
Low-quality base calls are treated as if they could be any of the four bases.
The type of relationship that would occur if the read base were each of the four
bases is determined.
The bytes for those relationships are united via <a class="reference external" href="https://en.wikipedia.org/wiki/Bitwise_operation#OR">bitwise OR</a> into a consensus
byte for the ambiguous relationship.</p>
<p>For example, suppose a low-quality base call in the read aligns to a T in the
reference.
If the read base (which is unknown because of its low quality) were actually A,
then the relationship would be a substitution to A (<code class="docutils literal notranslate"><span class="pre">00010000</span></code>).
Likewise if the read base were C (<code class="docutils literal notranslate"><span class="pre">00100000</span></code>) or G (<code class="docutils literal notranslate"><span class="pre">01000000</span></code>).
If the read base were T, then the relationship would be a match (<code class="docutils literal notranslate"><span class="pre">00000001</span></code>).
The bytes for these four possible situations are merged by taking the bitwise OR
into a consensus byte (<code class="docutils literal notranslate"><span class="pre">01110001</span></code>) that shows ambiguity in the relationship.
This consensus byte is inserted into the relation vector.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>If read were</p></th>
<th class="head"><p>Then relationship would be</p></th>
<th class="head"><p>Byte</p></th>
<th class="head"><p>Dec</p></th>
<th class="head"><p>Hex</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>A</p></td>
<td><p>Substitution to A</p></td>
<td><p>00010000</p></td>
<td><p>016</p></td>
<td><p>10</p></td>
</tr>
<tr class="row-odd"><td><p>C</p></td>
<td><p>Substitution to C</p></td>
<td><p>00100000</p></td>
<td><p>032</p></td>
<td><p>20</p></td>
</tr>
<tr class="row-even"><td><p>G</p></td>
<td><p>Substitution to G</p></td>
<td><p>01000000</p></td>
<td><p>064</p></td>
<td><p>40</p></td>
</tr>
<tr class="row-odd"><td><p>T</p></td>
<td><p>Match</p></td>
<td><p>00000001</p></td>
<td><p>001</p></td>
<td><p>01</p></td>
</tr>
<tr class="row-even"><td><p>Low-quality</p></td>
<td><p>Any of the above</p></td>
<td><p>01110001</p></td>
<td><p>113</p></td>
<td><p>71</p></td>
</tr>
</tbody>
</table>
<p>In the following table, each row repeats this calculation for one type of base
in the reference (column “Ref”).
Each column named “Read: A?” / “Read: C?” / “Read: G?” / “Read: T?” shows what
the relationship would be if the low-quality base in the read were actually the
base in the column header.
For example, in the first row, the reference base is A: if the read base were A,
then the relationship would be a match (<code class="docutils literal notranslate"><span class="pre">00000001</span></code>); and if it were C, then
the relationship would be a substitution to C (<code class="docutils literal notranslate"><span class="pre">00100000</span></code>).
The column “Byte” shows the resulting ambiguous relationship, the bitwise OR of
the four columns “Read: A/C/G/T?”.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Ref</p></th>
<th class="head"><p>Read: A?</p></th>
<th class="head"><p>Read: C?</p></th>
<th class="head"><p>Read: G?</p></th>
<th class="head"><p>Read: T?</p></th>
<th class="head"><p>Byte</p></th>
<th class="head"><p>Dec</p></th>
<th class="head"><p>Hex</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>A</p></td>
<td><p>00000001</p></td>
<td><p>00100000</p></td>
<td><p>01000000</p></td>
<td><p>10000000</p></td>
<td><p>11100001</p></td>
<td><p>225</p></td>
<td><p>e1</p></td>
</tr>
<tr class="row-odd"><td><p>C</p></td>
<td><p>00010000</p></td>
<td><p>00000001</p></td>
<td><p>01000000</p></td>
<td><p>10000000</p></td>
<td><p>11010001</p></td>
<td><p>209</p></td>
<td><p>d1</p></td>
</tr>
<tr class="row-even"><td><p>G</p></td>
<td><p>00010000</p></td>
<td><p>00100000</p></td>
<td><p>00000001</p></td>
<td><p>10000000</p></td>
<td><p>10110001</p></td>
<td><p>177</p></td>
<td><p>b1</p></td>
</tr>
<tr class="row-odd"><td><p>T</p></td>
<td><p>00010000</p></td>
<td><p>00100000</p></td>
<td><p>01000000</p></td>
<td><p>00000001</p></td>
<td><p>01110001</p></td>
<td><p>113</p></td>
<td><p>71</p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A byte that has more than one bit set to 1 does <strong>not</strong> count more than once
towards the total number of matches or mutations.
To learn how mutations in relation vectors are counted, see [REF].</p>
</div>
</section>
<section id="encoding-ambiguous-insertions-and-deletions">
<h3>Encoding ambiguous insertions and deletions<a class="headerlink" href="#encoding-ambiguous-insertions-and-deletions" title="Link to this heading"></a></h3>
<p>Insertions and deletions (collectively, “indels”) in the read cause ambiguities
that even the highest quality sequencing reads could not prevent.
When one or more bases are inserted or deleted in a repetitive sequence, the
exact base that mutated cannot be determined.
For example, if the reference is <code class="docutils literal notranslate"><span class="pre">ATCCTG</span></code> and the read is <code class="docutils literal notranslate"><span class="pre">ATCTG</span></code>, then one
C was clearly deleted from the read.
But determining whether it was the first or second C is impossible because the
alignments are equally good:</p>
<p><strong>Deletion of the first C</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">AT</span><span class="o">-</span><span class="n">CTG</span>
<span class="o">||</span> <span class="o">|||</span>
<span class="n">ATCCTG</span>
</pre></div>
</div>
<p><strong>Deletion of the second C</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ATC</span><span class="o">-</span><span class="n">TG</span>
<span class="o">|||</span> <span class="o">||</span>
<span class="n">ATCCTG</span>
</pre></div>
</div>
<p>Ambiguities in the location of a relationship are encoded by turning on the bit
of every possible relationship at each position.
In the above example, there could be a deletion (<code class="docutils literal notranslate"><span class="pre">00000010</span></code>) or a match
(<code class="docutils literal notranslate"><span class="pre">00000001</span></code>) at position 3 of the reference, so the byte it receives is the
bitwise OR of the two relationships: <code class="docutils literal notranslate"><span class="pre">00000011</span></code>.
Likewise for position 4.
Thus, the relationship byte at each position (Pos) in the alignment would be</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Pos</p></th>
<th class="head"><p>Byte</p></th>
<th class="head"><p>Hex</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td><p>00000001</p></td>
<td><p>01</p></td>
</tr>
<tr class="row-odd"><td><p>2</p></td>
<td><p>00000001</p></td>
<td><p>01</p></td>
</tr>
<tr class="row-even"><td><p>3</p></td>
<td><p>00000011</p></td>
<td><p>03</p></td>
</tr>
<tr class="row-odd"><td><p>4</p></td>
<td><p>00000011</p></td>
<td><p>03</p></td>
</tr>
<tr class="row-even"><td><p>5</p></td>
<td><p>00000001</p></td>
<td><p>01</p></td>
</tr>
<tr class="row-odd"><td><p>6</p></td>
<td><p>00000001</p></td>
<td><p>01</p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A byte that has more than one bit set to 1 does <strong>not</strong> count more than once
towards the total number of matches or mutations.
To learn how mutations in relation vectors are counted, see [REF].</p>
</div>
<p>To learn how the algorithm that finds ambiguous indels works, see [REF].</p>
</section>
</section>
<section id="encoding-positions-not-covered-by-the-read">
<h2>Encoding positions not covered by the read<a class="headerlink" href="#encoding-positions-not-covered-by-the-read" title="Link to this heading"></a></h2>
<p>If a read is shorter than the reference, then some positions in the reference
will not be covered by the read.
The “blank” positions to which the read does not align provide no information
and are thus considered fully ambiguous and assigned the byte <code class="docutils literal notranslate"><span class="pre">11111111</span></code>
(decimal 255, hexadecimal ff).</p>
</section>
<section id="encoding-paired-end-reads">
<h2>Encoding paired-end reads<a class="headerlink" href="#encoding-paired-end-reads" title="Link to this heading"></a></h2>
<p>For paired-end reads, both mates produce a relation vector.
They must be merged into one consensus relation vector to avoid double-counting
any positions where the two mates overlap.
Ideally, the mates would have identical relationships.
However, they often differ because a position is covered in one mate but not in
the other, one mate’s Phred score is above the threshold while the other’s is
below, or (more rarely) the base calls themselves differ.</p>
<section id="encoding-consensus-relationships">
<h3>Encoding consensus relationships<a class="headerlink" href="#encoding-consensus-relationships" title="Link to this heading"></a></h3>
<p>When finding the consensus of two mates, information in one mate should fill in
for a lack thereof in the other.
Recall that each byte indicates all possible relationships at its position.
The more bits that are set to 1, the more ambiguity (and the less knowledge)
there is about the relationship.
For one mate to add knowledge to the other, the consensus byte must thus have no
more 1s than the byte of either mate.
Specifically, a bit in the consensus should be 1 only if it is 1 in both mates.
This result is achieved using the <a class="reference external" href="https://en.wikipedia.org/wiki/Bitwise_operation#AND">bitwise AND</a> operation.</p>
<p>For example, consider the following mate 1 and mate 2, where the column “Result”
indicates the consensus byte after taking the bitwise AND:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Pos</p></th>
<th class="head"><p>Mate 1</p></th>
<th class="head"><p>Mate 2</p></th>
<th class="head"><p>Result</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td><p>00000001</p></td>
<td><p>00000001</p></td>
<td><p>00000001</p></td>
</tr>
<tr class="row-odd"><td><p>2</p></td>
<td><p>00000001</p></td>
<td><p>11010001</p></td>
<td><p>00000001</p></td>
</tr>
<tr class="row-even"><td><p>3</p></td>
<td><p>11100001</p></td>
<td><p>01000000</p></td>
<td><p>01000000</p></td>
</tr>
<tr class="row-odd"><td><p>4</p></td>
<td><p>11111111</p></td>
<td><p>00000001</p></td>
<td><p>00000001</p></td>
</tr>
<tr class="row-even"><td><p>5</p></td>
<td><p>11111111</p></td>
<td><p>01110001</p></td>
<td><p>01110001</p></td>
</tr>
<tr class="row-odd"><td><p>6</p></td>
<td><p>11111111</p></td>
<td><p>11111111</p></td>
<td><p>11111111</p></td>
</tr>
</tbody>
</table>
<p>At position 1, the mates agree on a match.
At position 2, mate 2 has low quality, but mate 1 has a high-quality match, so
that the result has only the match bit set to 1.
Similarly, at position 3, a substitution to G in mate 2 compensates for the low
quality base call in mate 1: substitution to G is the consensus.
Mate 1 does not cover the positions 4-6 (hence the blank bytes <code class="docutils literal notranslate"><span class="pre">11111111</span></code>).
Mate 2 informs that position 4 is a match, but it is low quality at position 5,
so even the consensus byte is ambiguous.
Neither mate covers position 6, so the consensus byte is blank.</p>
</section>
<section id="encoding-irreconcilable-relationships">
<h3>Encoding irreconcilable relationships<a class="headerlink" href="#encoding-irreconcilable-relationships" title="Link to this heading"></a></h3>
<p>It is possible, although rare, for mates 1 and 2 to share no bits.
For example, if mate 1 were a high-quality match (<code class="docutils literal notranslate"><span class="pre">00000001</span></code>) and mate 2 were
a high-quality substitution to T (<code class="docutils literal notranslate"><span class="pre">10000000</span></code>), then the bitwise AND would be
all zeros (<code class="docutils literal notranslate"><span class="pre">00000000</span></code>).
The mates would be irreconcilable at this position.</p>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="index.html" class="btn btn-neutral float-left" title="Relate Data Structures" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="relate.html" class="btn btn-neutral float-right" title="Relate Batch" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, the Rouskin Lab.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>